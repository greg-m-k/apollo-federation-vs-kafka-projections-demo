apiVersion: v1
kind: ConfigMap
metadata:
  name: router-config
  namespace: federation-demo
data:
  router.yaml: |
    supergraph:
      listen: 0.0.0.0:4000
      introspection: true
    cors:
      allow_any_origin: true
      expose_headers:
        - X-Subgraph-Time-Ms
        - X-Timing-Details
        - X-HR-Time-Ms
        - X-Employment-Time-Ms
        - X-Security-Time-Ms
        - X-HR-Timing-Details
        - X-Employment-Timing-Details
        - X-Security-Timing-Details
    homepage:
      enabled: false
    sandbox:
      enabled: true
    health_check:
      listen: 0.0.0.0:8088
      enabled: true
    include_subgraph_errors:
      all: true
    rhai:
      scripts: /config
      main: timing.rhai
    telemetry:
      exporters:
        logging:
          stdout:
            enabled: true
            format: json
    plugins:
      experimental.expose_query_plan: true
  timing.rhai: |
    // Rhai script to propagate timing headers from subgraphs to the final response

    fn supergraph_service(service) {
        let add_timing_to_response = |response| {
            // Total time per subgraph
            let hr_time = response.context["hr_time_ms"];
            if hr_time != () {
                response.headers["X-HR-Time-Ms"] = hr_time;
            }

            let emp_time = response.context["employment_time_ms"];
            if emp_time != () {
                response.headers["X-Employment-Time-Ms"] = emp_time;
            }

            let sec_time = response.context["security_time_ms"];
            if sec_time != () {
                response.headers["X-Security-Time-Ms"] = sec_time;
            }

            // Detailed timing breakdown per subgraph
            let hr_details = response.context["hr_timing_details"];
            if hr_details != () {
                response.headers["X-HR-Timing-Details"] = hr_details;
            }

            let emp_details = response.context["employment_timing_details"];
            if emp_details != () {
                response.headers["X-Employment-Timing-Details"] = emp_details;
            }

            let sec_details = response.context["security_timing_details"];
            if sec_details != () {
                response.headers["X-Security-Timing-Details"] = sec_details;
            }
        };

        service.map_response(add_timing_to_response);
    }

    fn subgraph_service(service, subgraph) {
        let capture_timing = |response| {
            if subgraph == "hr" {
                if "x-hr-time-ms" in response.headers {
                    response.context.hr_time_ms = response.headers["x-hr-time-ms"];
                }
                if "x-timing-details" in response.headers {
                    response.context.hr_timing_details = response.headers["x-timing-details"];
                }
            }

            if subgraph == "employment" {
                if "x-employment-time-ms" in response.headers {
                    response.context.employment_time_ms = response.headers["x-employment-time-ms"];
                }
                if "x-timing-details" in response.headers {
                    response.context.employment_timing_details = response.headers["x-timing-details"];
                }
            }

            if subgraph == "security" {
                if "x-security-time-ms" in response.headers {
                    response.context.security_time_ms = response.headers["x-security-time-ms"];
                }
                if "x-timing-details" in response.headers {
                    response.context.security_timing_details = response.headers["x-timing-details"];
                }
            }
        };

        service.map_response(capture_timing);
    }
  supergraph.graphql: |
    schema
      @link(url: "https://specs.apollo.dev/link/v1.0")
      @link(url: "https://specs.apollo.dev/join/v0.3", for: EXECUTION)
    {
      query: Query
      mutation: Mutation
    }
    directive @join__enumValue(graph: join__Graph!) repeatable on ENUM_VALUE
    directive @join__field(graph: join__Graph, requires: join__FieldSet, provides: join__FieldSet, type: String, external: Boolean, override: String, usedOverridden: Boolean) repeatable on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
    directive @join__graph(name: String!, url: String!) on ENUM_VALUE
    directive @join__implements(graph: join__Graph!, interface: String!) repeatable on OBJECT | INTERFACE
    directive @join__type(graph: join__Graph!, key: join__FieldSet, extension: Boolean! = false, resolvable: Boolean! = true, isInterfaceObject: Boolean! = false) repeatable on OBJECT | INTERFACE | UNION | ENUM | INPUT_OBJECT | SCALAR
    directive @join__unionMember(graph: join__Graph!, member: String!) repeatable on UNION
    directive @link(url: String, as: String, for: link__Purpose, import: [link__Import]) repeatable on SCHEMA
    scalar BigDecimal @join__type(graph: EMPLOYMENT)
    scalar Date @join__type(graph: HR)
    scalar join__FieldSet
    scalar link__Import
    enum AccessLevel @join__type(graph: SECURITY) {
      VISITOR @join__enumValue(graph: SECURITY)
      STANDARD @join__enumValue(graph: SECURITY)
      RESTRICTED @join__enumValue(graph: SECURITY)
      ALL_ACCESS @join__enumValue(graph: SECURITY)
    }
    enum Clearance @join__type(graph: SECURITY) {
      NONE @join__enumValue(graph: SECURITY)
      CONFIDENTIAL @join__enumValue(graph: SECURITY)
      SECRET @join__enumValue(graph: SECURITY)
      TOP_SECRET @join__enumValue(graph: SECURITY)
    }
    enum join__Graph {
      HR @join__graph(name: "hr", url: "http://hr-subgraph:8080/graphql")
      EMPLOYMENT @join__graph(name: "employment", url: "http://employment-subgraph:8080/graphql")
      SECURITY @join__graph(name: "security", url: "http://security-subgraph:8080/graphql")
    }
    enum link__Purpose {
      SECURITY
      EXECUTION
    }
    type BadgeHolder @join__type(graph: SECURITY, key: "id") {
      id: ID!
      personId: ID!
      badgeNumber: String!
      accessLevel: AccessLevel!
      clearance: Clearance!
      active: Boolean!
    }
    type Employee @join__type(graph: EMPLOYMENT, key: "id") {
      id: ID!
      personId: ID!
      title: String!
      department: String!
      salary: BigDecimal!
      active: Boolean!
    }
    type Person @join__type(graph: HR, key: "id") @join__type(graph: EMPLOYMENT, key: "id", extension: true) @join__type(graph: SECURITY, key: "id", extension: true) {
      id: ID!
      name: String! @join__field(graph: HR)
      email: String! @join__field(graph: HR)
      hireDate: Date @join__field(graph: HR)
      active: Boolean! @join__field(graph: HR)
      employee: Employee @join__field(graph: EMPLOYMENT)
      badge: BadgeHolder @join__field(graph: SECURITY)
    }
    type Query @join__type(graph: HR) @join__type(graph: EMPLOYMENT) @join__type(graph: SECURITY) {
      persons: [Person!]! @join__field(graph: HR)
      person(id: ID!): Person @join__field(graph: HR)
      personByEmail(email: String!): Person @join__field(graph: HR)
      activePersons: [Person!]! @join__field(graph: HR)
      searchPersons(name: String!): [Person!]! @join__field(graph: HR)
      employees: [Employee!]! @join__field(graph: EMPLOYMENT)
      employee(id: ID!): Employee @join__field(graph: EMPLOYMENT)
      employeeByPersonId(personId: ID!): Employee @join__field(graph: EMPLOYMENT)
      employeesByDepartment(department: String!): [Employee!]! @join__field(graph: EMPLOYMENT)
      activeEmployees: [Employee!]! @join__field(graph: EMPLOYMENT)
      badgeHolders: [BadgeHolder!]! @join__field(graph: SECURITY)
      badgeHolder(id: ID!): BadgeHolder @join__field(graph: SECURITY)
      badgeHolderByPersonId(personId: ID!): BadgeHolder @join__field(graph: SECURITY)
      badgeHolderByBadgeNumber(badgeNumber: String!): BadgeHolder @join__field(graph: SECURITY)
      badgeHoldersByAccessLevel(accessLevel: AccessLevel!): [BadgeHolder!]! @join__field(graph: SECURITY)
      activeBadgeHolders: [BadgeHolder!]! @join__field(graph: SECURITY)
    }
    type Mutation @join__type(graph: HR) @join__type(graph: EMPLOYMENT) @join__type(graph: SECURITY) {
      createPerson(name: String!, email: String!, hireDate: Date): Person! @join__field(graph: HR)
      updatePerson(id: ID!, name: String, email: String): Person @join__field(graph: HR)
      terminatePerson(id: ID!): Person @join__field(graph: HR)
      assignEmployee(personId: ID!, title: String!, department: String!, salary: BigDecimal!): Employee @join__field(graph: EMPLOYMENT)
      promoteEmployee(id: ID!, newTitle: String, newSalary: BigDecimal): Employee @join__field(graph: EMPLOYMENT)
      transferEmployee(id: ID!, newDepartment: String!): Employee @join__field(graph: EMPLOYMENT)
      terminateEmployee(id: ID!): Employee @join__field(graph: EMPLOYMENT)
      provisionBadge(personId: ID!, accessLevel: AccessLevel!, clearance: Clearance!): BadgeHolder @join__field(graph: SECURITY)
      changeAccessLevel(id: ID!, newAccessLevel: AccessLevel!): BadgeHolder @join__field(graph: SECURITY)
      changeClearance(id: ID!, newClearance: Clearance!): BadgeHolder @join__field(graph: SECURITY)
      revokeBadge(id: ID!): BadgeHolder @join__field(graph: SECURITY)
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: router
  namespace: federation-demo
spec:
  replicas: 1
  selector:
    matchLabels:
      app: router
  template:
    metadata:
      labels:
        app: router
    spec:
      containers:
        - name: router
          image: ghcr.io/apollographql/router:v1.57.1
          ports:
            - containerPort: 4000
            - containerPort: 8088
          args:
            - --config
            - /config/router.yaml
            - --supergraph
            - /config/supergraph.graphql
          volumeMounts:
            - name: config
              mountPath: /config
          readinessProbe:
            httpGet:
              path: /health
              port: 8088
            initialDelaySeconds: 5
            periodSeconds: 5
          resources:
            limits:
              memory: "256Mi"
              cpu: "250m"
      volumes:
        - name: config
          configMap:
            name: router-config
---
apiVersion: v1
kind: Service
metadata:
  name: router
  namespace: federation-demo
spec:
  type: NodePort
  selector:
    app: router
  ports:
    - name: graphql
      port: 4000
      targetPort: 4000
      nodePort: 30400
    - name: health
      port: 8088
      targetPort: 8088
